<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络io与io多路复用</title>
      <link href="/2024/12/18/1.1%20%E7%BD%91%E7%BB%9Cio%E4%B8%8Eio%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
      <url>/2024/12/18/1.1%20%E7%BD%91%E7%BB%9Cio%E4%B8%8Eio%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="2-1-网络IO与IO多路复用"><a href="#2-1-网络IO与IO多路复用" class="headerlink" title="2.1 网络IO与IO多路复用"></a>2.1 网络IO与IO多路复用</h1><h2 id="2-1-1思考以下操作，与网络IO有什么关系呢？"><a href="#2-1-1思考以下操作，与网络IO有什么关系呢？" class="headerlink" title="2.1.1思考以下操作，与网络IO有什么关系呢？"></a>2.1.1思考以下操作，与网络IO有什么关系呢？</h2><ol><li><p>在生活中，我们使用微信，发送文字，视频，语音，</p></li><li><p>刷抖音时，打开一个视频，视频资源怎么到达我们的<code>APP</code>的？</p></li><li><p>github/gitlab , git clone  为什么代码能到达本地？</p></li><li><p>扫描共享单车二维码，能够打开车锁，</p></li><li><p>通过APP操纵空调</p></li><li><p>王者荣耀 释放技能 造成了伤害</p><p>以上流程都有着server &lt;-&gt; client之间的交互，网络IO在日常生活中数据传输和交互中的重要作用。</p></li></ol><h3 id="2-1-2-客户端和服务端-进行通信："><a href="#2-1-2-客户端和服务端-进行通信：" class="headerlink" title="2.1.2 客户端和服务端 进行通信："></a>2.1.2 客户端和服务端 进行通信：</h3><h4 id="2-1-2-1-简易的客户端："><a href="#2-1-2-1-简易的客户端：" class="headerlink" title="2.1.2.1 简易的客户端："></a>2.1.2.1 简易的客户端：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 192.168.133.128 3263</span><br></pre></td></tr></table></figure><h4 id="2-1-2-2-仅链接一次的简易服务端："><a href="#2-1-2-2-仅链接一次的简易服务端：" class="headerlink" title="2.1.2.2 仅链接一次的简易服务端："></a>2.1.2.2 仅链接一次的简易服务端：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line"></span><br><span class="line">    servaddr.sin_family = AF_INET;                  <span class="comment">// 指定IP地址地址版本 为IPV4</span></span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);   <span class="comment">// 绑定本地0.0.0.0</span></span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">3264</span>); <span class="comment">//0~1023 系统默认，需要给一个大于1024的地址，小于65535</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">bind</span>(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;servaddr,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr)))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt;<span class="string">&quot;bind failed :\n&quot;</span> ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">listen</span>(sockfd,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listen finished\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientaddr;</span><br><span class="line"><span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="type">int</span> clientfd = <span class="built_in">accept</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, &amp;len);  <span class="comment">//会阻塞，直至第一次来连接</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;accept finished\n&quot;</span>);</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> count = <span class="built_in">recv</span>(clientfd, buffer, <span class="number">1024</span>, <span class="number">0</span>); <span class="comment">// 会阻塞，直至收到消息</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">            std::cout &lt;&lt;<span class="string">&quot;client closed!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;RECV:%s\n&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>端口被绑定以后，不可再次绑定</li><li>执行listen以后，可以看到io的状态</li><li>进入listen可以被连接，并且会产生新的连接状态LISTEN。并且客户端可以发送数据</li><li>fd是io，Tcp链接是accept建立连接</li></ul><h4 id="2-1-2-3-一请求一线程的处理方案"><a href="#2-1-2-3-一请求一线程的处理方案" class="headerlink" title="2.1.2.3 一请求一线程的处理方案"></a>2.1.2.3 一请求一线程的处理方案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../base_tool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_CREATE_FUNC 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> THREAD_CREATE_FUNC</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">client_thread</span><span class="params">(<span class="type">void</span>* sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> client_fd = *(<span class="type">int</span>*)sockfd;</span><br><span class="line">     <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;accept finished\n&quot;</span>);</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> count = <span class="built_in">recv</span>(client_fd, buffer, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">            std::cout &lt;&lt;<span class="string">&quot;client closed!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;RECV:%s\n&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">client_thread</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;accept finished\n&quot;</span>);</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> count = <span class="built_in">recv</span>(sockfd, buffer, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">            std::cout &lt;&lt;<span class="string">&quot;client closed!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;RECV:%s\n&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建一个socket</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line"></span><br><span class="line">    servaddr.sin_family = AF_INET;                  <span class="comment">// 指定IP地址地址版本 为IPV4</span></span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);   <span class="comment">// 绑定本地0.0.0.0</span></span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">3264</span>); <span class="comment">//0~1023 系统默认，需要给一个大于1024的地址，小于65535</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">bind</span>(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;servaddr,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr)))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt;<span class="string">&quot;bind failed :\n&quot;</span> ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">listen</span>(sockfd,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listen finished\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程方法1：</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> THREAD_CREATE_FUNC</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientaddr;</span><br><span class="line"><span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> clientfd = <span class="built_in">accept</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, &amp;len);</span><br><span class="line">        <span class="comment">// std::thread()</span></span><br><span class="line">        <span class="keyword">if</span> (clientfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">pthread_t</span> thread_id;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;thread_id, <span class="literal">NULL</span>, client_thread, (<span class="type">void</span> *)&amp;clientfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">//创建线程方法2：</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientaddr;</span><br><span class="line"><span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> clientfd = <span class="built_in">accept</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (clientfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function">std::thread <span class="title">t1</span><span class="params">(client_thread,clientfd)</span></span>;</span><br><span class="line">            t<span class="number">1.</span><span class="built_in">detach</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一请求一线程的处理方案</strong> 存在的问题：</p><h4 id="1-资源消耗高"><a href="#1-资源消耗高" class="headerlink" title="1. 资源消耗高"></a>1. <strong>资源消耗高</strong></h4><ul><li><strong>线程开销</strong>：每个线程都需要一定的系统资源，包括线程栈、线程控制块等。创建大量线程会消耗更多的内存和 CPU 资源，可能导致系统性能下降。</li><li><strong>上下文切换</strong>：线程过多会导致频繁的上下文切换，这会消耗 CPU 时间，影响应用程序的整体性能。</li></ul><h4 id="2-可扩展性差"><a href="#2-可扩展性差" class="headerlink" title="2. 可扩展性差"></a>2. <strong>可扩展性差</strong></h4><ul><li>当并发连接数目增加时，系统可能会达到最大线程数的限制，无法再创建新线程。这种情况下，新的请求可能被拒绝，降低了系统的可用性。</li><li>在高并发环境下，创建和管理大量线程的复杂性增加，会增加开发和维护成本。</li></ul><h4 id="3-负载均衡问题"><a href="#3-负载均衡问题" class="headerlink" title="3. 负载均衡问题"></a>3. <strong>负载均衡问题</strong></h4><ul><li>在某些情况下，同一时间处理的请求可能会导致某些线程长时间处于活动状态，而其他线程却处于空闲状态，从而造成资源的不均匀分配。</li></ul><h4 id="4-设计复杂性"><a href="#4-设计复杂性" class="headerlink" title="4. 设计复杂性"></a>4. <strong>设计复杂性</strong></h4><ul><li>需要处理多线程带来的同步和共享数据的问题，这会增加代码的复杂性和潜在的错误风险。</li></ul><h4 id="5-延迟"><a href="#5-延迟" class="headerlink" title="5. 延迟"></a>5. <strong>延迟</strong></h4><ul><li>对于短暂的小请求，线程的创建和销毁可能比请求本身的处理时间还要长，因此会引入不必要的延迟。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cpp Primer 阅读笔记!</title>
      <link href="/2024/10/22/Cpp%20primer%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/10/22/Cpp%20primer%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="2-变量和基本类型"><a href="#2-变量和基本类型" class="headerlink" title="2. 变量和基本类型"></a>2. 变量和基本类型</h1><h2 id="2-1变量"><a href="#2-1变量" class="headerlink" title="2.1变量"></a>2.1变量</h2><h3 id="2-1-1-对象的定义"><a href="#2-1-1-对象的定义" class="headerlink" title="2.1.1 对象的定义"></a>2.1.1 对象的定义</h3><p>​        具有某种数据类型的内存空间</p><h3 id="2-1-2-变量的初始化"><a href="#2-1-2-变量的初始化" class="headerlink" title="2.1.2 变量的初始化"></a>2.1.2 变量的初始化</h3><p>​    <strong>建议</strong>：当你第一次使用变量时再定义它，一般来说，在对象第一次被使用的地方附近定义它是一种好的选择，以为内这样做有助于更容易地找到变量的定义。更重要的是，当变量的定义与第一次被使用的地方很近时，我们也会赋给它一个比较合理的初始值。</p><ul><li><p>变量的初始化和赋值是不同的，初始化不是赋值，<strong>初始化的含义</strong>是创建变量时赋予其一个初始值，而<strong>赋值的含义</strong>是把对象当前的值擦除，而以一个新值来替代</p></li><li><p>定义于任何函数体之外的变量被初始化为0</p></li><li><p>定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值，将引发错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a ; <span class="comment">// 由于此处未给a进行初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d&quot;</span>, a);  <span class="comment">//对a进行了访问，在VS中编译将会报错，而在linux中则可以正常运行，但是数值每次运行程序时，并不固定</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%d&quot;</span>, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>每个类各自决定其初始化对象的方式，而且，是否允许不经初始化就定义对象也由类自己决定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span><span class="comment">//在C语言使用malloc需要引用stdlib.h,如果使用iostream则无需另外添加stdlib.h</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Another</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Another</span>* struc = (<span class="keyword">struct</span> Another*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> Another));</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d&quot;</span>, struc-&gt;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%d&quot;</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d=%d&quot;</span>);<span class="comment">//警告C6064   缺少“printf”的整型参数(对应于转换说明符“1”)。  会打印出来不被定义的值 -1282888768(该值多次运行并不一定)，且多次打印  format ‘%d’ expects a matching ‘int’ argument </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d=%d&quot;</span>);<span class="comment">//警告C6064   缺少“printf”的整型参数(对应于转换说明符“1”)。  会打印出来不被定义的值 -1282888768，和上方一样</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-1-3-列表初始化"><a href="#2-1-3-列表初始化" class="headerlink" title="2.1.3 列表初始化"></a>2.1.3 列表初始化</h3><p>​        作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用，而在此之前，这种初始化的性质仅在某些受限的场合下才能使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// int units_sold = 0;</span></span><br><span class="line">    <span class="comment">// int units_sold = &#123;0&#125;;</span></span><br><span class="line">    <span class="comment">// int units_sold&#123;0&#125;;</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    std::cout&lt;&lt;units_sold&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用于内置类型的变量时，这种初始化形式有一个重要特点，如果我们使用列表初始化，且初始值存在丢失信息的风险，则编译器报错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> ld = <span class="number">3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679</span>;</span><br><span class="line">    <span class="type">int</span> a&#123;ld&#125;,b = &#123;ld&#125;;<span class="comment">//这里在VS里面会直接不过编译，报错，但是在linux只会warning // C++11 style initialization</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">(ld)</span>,d </span>= ld; <span class="comment">// C++98 style initialization</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**LINUX**</span></span><br><span class="line"><span class="comment">//warning: narrowing conversion of ‘ld’ from ‘long double’ to ‘int’ [-Wnarrowing]  可以通过编译</span></span><br><span class="line"><span class="comment">//   10 |     int a&#123;ld&#125;,b = &#123;ld&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//**WINDOWS**</span></span><br><span class="line"><span class="comment">//错误C2397从“long double”转换到“int”需要收缩转换testCC:\Users\24854\source\repos\testC\testC\testC.cpp7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-1-4-变量声明和定义的关系"><a href="#2-1-4-变量声明和定义的关系" class="headerlink" title="2.1.4 变量声明和定义的关系"></a>2.1.4 变量声明和定义的关系</h3><ul><li>extern用法示例</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span><span class="comment">//在C语言使用malloc需要引用stdlib.h,如果使用iostream则无需另外添加stdlib.h</span></span></span><br><span class="line"><span class="comment">//#include &quot;new.cpp&quot;  //ERROR!  注意，这里不可以include &quot;new.cpp&quot;  变量只能被定义一次，但是可以多次被声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> p;      <span class="comment">//这里只是声明</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">func</span><span class="params">()</span></span>; <span class="comment">//这里只是声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//new.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NEW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEW_H</span></span><br><span class="line"><span class="type">int</span> p = <span class="number">15</span>;  <span class="comment">// 可以是变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="comment">// 也可以是函数</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li>变量的声明和定义：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">相关知识介绍</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">//声明了i而非定义i</span></span><br><span class="line"><span class="type">int</span> j;        <span class="comment">//声明并定义j</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> pi = <span class="number">3.1416</span>;  <span class="comment">//定义pi(没有声明)</span></span><br></pre></td></tr></table></figure><ul><li><strong>C</strong>++是一种<strong>静态类型(statically typed)语言</strong>，其含义是在编译阶段检查类型，其中，检查类型的过程称为<strong>类型检查</strong>(type checking)。<ul><li>我们已经知道，对象的类型决定了对象所能参与的运算。在C++语言中，编译器负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错，并且不会生成可执行文件。</li><li>程序越复杂，静态类型检查越有助于发现问题。然而，前提是编译器必须知道每一个实体对象的类型，这就要求我们在使用某个变量之前，必须声明其型。</li></ul></li></ul><h2 id="2-2-复合类型"><a href="#2-2-复合类型" class="headerlink" title="2.2 复合类型"></a>2.2 复合类型</h2><p>​        <strong>复合类型(compound type)</strong>是指基于其他类型定义的类型 ，C++语言有几种复合类型，本章将介绍其中的几种：引用和指针。</p><p>​        与我们已经掌握的变量声明相比，定义复合类型的变量要复杂很多。</p><ul><li><p>普通变量的定义方式：</p><ul><li>一条简单的声明语句由一个数据类型和紧随其后的一个变量名列表组成。</li><li>更通用的描述： 一条声明语句由一个基本数据类型和紧随其的一个声明符列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型</li></ul><p>目前为止，我们所接触的声明语句中，声明符其实就是变量名，此时变量的类型也就是声明的基本数据类型，其实还可能有更复杂的声明符，它基于基本数据类型得到更复杂的类型，并把它指定给变量。</p></li></ul><h3 id="2-2-1-左值引用-右值引用暂时不介绍"><a href="#2-2-1-左值引用-右值引用暂时不介绍" class="headerlink" title="2.2.1 左值引用(右值引用暂时不介绍)"></a>2.2.1 左值引用(右值引用暂时不介绍)</h3><p>​        <strong>引用(reference)</strong> 为对象起了另外一个名字，引用类型引用(refers to)另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival =<span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal = ival;</span><br><span class="line"><span class="type">int</span> &amp;refVal2 ;<span class="comment">//ERROR,引用必须被初始化</span></span><br></pre></td></tr></table></figure><p>​        一般在初始化变量时，初始值会被拷贝到新建的对象中。</p><p>​        然而定义引用时，程序把引用和它的初始值 <strong>绑定(bind)</strong> 在一起，而不是将初始值直接拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为<strong>无法令引用重新绑定到另外一个对象</strong>，因此<strong>引用必须初始化</strong>。<font color=red> 注意：引用的初始化流程有所区别  </font> </p><p>​        引用并非对象，相反的，它只是<strong>为一个已经存在的对象所起的另一个名字</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">refVal = <span class="number">2</span>;<span class="comment">// 把2赋给refVal指向的对象，此处即是赋给了ival</span></span><br><span class="line"><span class="type">int</span> ii = refVal;<span class="comment">//与ii = ival 执行结果相同</span></span><br></pre></td></tr></table></figure><p>​        允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1024</span>, i2 = <span class="number">2048</span>;<span class="comment">// i和i2都是int</span></span><br><span class="line"><span class="type">int</span> &amp;r = i,r2 = i2;     <span class="comment">// r是一个引用，与i绑定在一起，r2是int</span></span><br><span class="line"><span class="type">int</span> i3 = <span class="number">1024</span>,&amp;ri = i3; <span class="comment">// i3是int，ri是一个引用，与i3绑定在一起</span></span><br><span class="line"><span class="type">int</span> &amp;r3 = i3,&amp;r4 = i2;  <span class="comment">//r3 r4都是引用</span></span><br></pre></td></tr></table></figure><p>​            引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起，同时，在大部分情况下，所有的引用类型都要和与之绑定的对象严格匹配。</p><h3 id="2-2-2-指针"><a href="#2-2-2-指针" class="headerlink" title="2.2.2 指针"></a>2.2.2 指针</h3><p>​        <strong>指针(pointer)</strong>是指向另外一种类型的复合类型。</p><h4 id="2-2-2-1：指针和引用的区别："><a href="#2-2-2-1：指针和引用的区别：" class="headerlink" title="2.2.2.1：指针和引用的区别："></a>2.2.2.1：指针和引用的区别：</h4><ul><li>指针本身就是一个对象，允许对指针赋值和拷贝。而且指针的生命周期内它可以先后指向几个不同的对象</li><li>指针在定义的时候无需赋初值。和其他内置类型一样，如果没初始化，也会有不确定的值。（野指针）</li></ul><h4 id="2-2-2-2：-获取对象的地址："><a href="#2-2-2-2：-获取对象的地址：" class="headerlink" title="2.2.2.2： 获取对象的地址："></a>2.2.2.2： 获取对象的地址：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival;<span class="comment">//p存放变量ival的地址，</span></span><br></pre></td></tr></table></figure><p>​        在大部分情况下，所有的指针类型也都要和与之绑定的对象严格匹配。</p><h4 id="2-2-2-3-空指针"><a href="#2-2-2-3-空指针" class="headerlink" title="2.2.2.3 空指针"></a>2.2.2.3 空指针</h4><p>空指针(null pointer)不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">nullptr</span>;   <span class="comment">//等价于int *p1 = 0;</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="number">0</span>;<span class="comment">// 直接将p2初始化为字面常量0</span></span><br><span class="line"><span class="comment">//需要先include cstdlib</span></span><br><span class="line"><span class="type">int</span> *p3 = <span class="literal">NULL</span>;  <span class="comment">//等价于int *p3 = 0;</span></span><br></pre></td></tr></table></figure><p><strong>当基类指针指向派生类的时候，若基类析构函数不声明为虚函数，在析构时，只会调用基类而不会调用派生类的析构函数，从而导致内存泄露。</strong></p><h2 id="2-3-const-限定符"><a href="#2-3-const-限定符" class="headerlink" title="2.3 const 限定符"></a>2.3 const 限定符</h2><p>​        有时我们希望定义这样一种变量，它的值不能改变。为了满足这一要求，可以用<strong>const</strong>对变量的类型加以限定</p><p>​        值得注意的是：const对象一旦创建之后就不可以再改变，所以const对象必须初始化。</p><h3 id="2-3-1-const-变量的初始化特性"><a href="#2-3-1-const-变量的初始化特性" class="headerlink" title="2.3.1 const 变量的初始化特性"></a>2.3.1 const 变量的初始化特性</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> k;   <span class="comment">//错误，k是一个未经初始化的常量</span></span><br></pre></td></tr></table></figure><p>​        在不改变const对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对象，则他们是不是const都无关紧要。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci =i;<span class="comment">// 正确：i的值被拷贝给了ci</span></span><br><span class="line"><span class="type">int</span> j = ci;  <span class="comment">// 正确：ci的值被拷贝给了j</span></span><br></pre></td></tr></table></figure><p>​        尽管ci是整型常量，但无论如何ci中的值还是一个整型数，ci的常量特征仅仅在执行改变ci的操作时才会发挥作用。当用ci去初始化j时，根本无需在意ci是不是一个常量。拷贝一个对象的值并不会改变他一旦拷贝完成，新的对象就和原来的对象没什么关系了。</p><h3 id="2-3-2-一般情况下，const变量不能跨文件"><a href="#2-3-2-一般情况下，const变量不能跨文件" class="headerlink" title="2.3.2 一般情况下，const变量不能跨文件"></a>2.3.2 一般情况下，const变量不能跨文件</h3><ul><li><p>默认状态下，const对象仅在文件内有效</p><p>​        当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> bufSize = <span class="number">512</span>; <span class="comment">// 输入缓冲区大小</span></span><br></pre></td></tr></table></figure><p>​        <font color=red><strong>编译器将在编译的过程中，把所有用到bufSize的地方都替换成对应的值。</strong></font></p><p>​        为了执行上述替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了const对象的文件都必须得能访问到它的初始值才行。要做到这一点，就必须在<strong>每一个用到变量的文件都有对它的定义</strong>。</p><p>​        为了支持这一用法，同时避免对同一变量的重复定义，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。</p></li></ul><h3 id="2-3-3-如何实现const变量的跨文件使用？"><a href="#2-3-3-如何实现const变量的跨文件使用？" class="headerlink" title="2.3.3 如何实现const变量的跨文件使用？"></a>2.3.3 如何实现const变量的跨文件使用？</h3><p>​        某些时候，有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们<strong>不希望编译器为每个文件分别生成独立的变量</strong>。相反，我们想让这类cosnt对象像其他（非常量）对象一样工作： <strong>只在一个文件中定义const，而在多个文件的声明中使用它</strong>。</p><ul><li><p>如何只在一个文件中定义const变量，但在多个文件中使用它呢？</p><p>解决的办法是：<strong>对于const变量不管是声明还是定义都添加extern关键字</strong>，这样只需要定义一次就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file_1.cc 定义并初始化了一个常量，该常量能被抢其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">fcn</span>(); <span class="comment">//是只定义</span></span><br><span class="line"><span class="comment">// file_1.h  头文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize; <span class="comment">//与file_1.cc 中定义的bufSize是同一个 是声明</span></span><br></pre></td></tr></table></figure><p>​        如上述程序所示，file_1.cc 定义并初始化了bufSize 。因为这条语句包含了初始值，所以它是一次定义。然而，因为 bufSize 是一个常量，必须用 extern 加以限定使其被其他文件使用。</p><p>​        file_1.h 头文件中的声明也由extern 做了限定，其作用是指明bufSize 并非本文件所独有，它的定义将在别处出现。</p><p>​        如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。</p></li></ul><h3 id="2-3-4-Const-的引用："><a href="#2-3-4-Const-的引用：" class="headerlink" title="2.3.4 Const 的引用："></a>2.3.4 Const 的引用：</h3><p>​        可以把引用绑定到<code>const</code>对象上，就像绑定到其他对象上一样，我们称之为对<strong>常量的引用(reference to const)</strong>与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：</p><p>​        引用的类型必须与其所引用对象的类型一致。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = ci; <span class="comment">//正确：引用及其对应的对象都是常量</span></span><br><span class="line">ri = <span class="number">42</span>;  <span class="comment">//错误：r1是对常量的引用</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = ci;<span class="comment">//错误：试图让一个非常量引用指向一个常量对象</span></span><br></pre></td></tr></table></figure><p>​    “对<code>const</code>的引用”简称为”常量引用”，但严格来说，并不存在常量引用。因为引用不是一个对象，所以我们无法让引用本身恒定不变。事实上，由于C++语言并不允许随意改变引用所绑定的对象，所以从这层意义上理解，所有的引用有都算是常量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> i = <span class="number">5.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ref = i;  <span class="comment">//正确，实际上运行过程为const int temp = i; const int &amp; ref = temp;</span></span><br><span class="line"><span class="type">int</span>&amp; p = i; <span class="comment">//错误，引用有严格的类型检查，绑定的对象一定和自己的类型一致</span></span><br></pre></td></tr></table></figure><p>​        除此之外，<code>const int&amp;</code> 和<code>int const &amp;</code> 是完全等价的，两者都是对整数的常量引用，<code>const</code>的位置不影响语义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> i = <span class="number">1024</span>; </span><br><span class="line">   <span class="type">const</span> <span class="type">int</span>&amp; const_int_i = i;  <span class="comment">// 对cosnt的引用可能引用一个并费const的对象</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span>&amp; const_double_i = i;</span><br><span class="line">   <span class="type">int</span>&amp; refi = i;</span><br><span class="line">   i = <span class="number">5</span>;</span><br><span class="line">   std::cout &lt;&lt; const_int_i &lt;&lt; std::endl;      <span class="comment">// 5，常量引用会正常的修改到</span></span><br><span class="line">std::cout &lt;&lt; const_double_i &lt;&lt; std::endl;<span class="comment">// 1024，修改了类型的常量流程为实际上运行过程为const int      // temp = i; const int &amp; ref = temp;</span></span><br><span class="line">             <span class="comment">// 是额外开辟了一个变量，所以不会被修改到。</span></span><br><span class="line">std::cout &lt;&lt; refi &lt;&lt; std::endl;  <span class="comment">//  5, refi 被修改到了</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; r2 = <span class="number">24</span>; <span class="comment">//正确， const int temp = 24;  const int&amp; r2 = temp;(实际上)</span></span><br></pre></td></tr></table></figure><h3 id="2-3-5-指针和const"><a href="#2-3-5-指针和const" class="headerlink" title="2.3.5 指针和const"></a>2.3.5 指针和const</h3><p>​        与引用一样，也可以令指针指向常量或非常量。类似于常量引用，<strong>指向常量的指针</strong><code>(pointer to const)</code>不能改变其所指对象的值  <font color=red>不能改变指向的对象的值</font>,即*p不可修改。要想存放常量对象的地址，只能使用指向常量的指针： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>    <span class="comment">// pi是个常量，它的值不可以改变</span></span><br><span class="line">   <span class="type">double</span> *ptr = &amp;pi ;       <span class="comment">// 错误：prt是一个普通指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr  = &amp;pi;<span class="comment">// 正确，cptr可以指向一个双精度常量</span></span><br><span class="line">*cptr = <span class="number">42</span>;    <span class="comment">// 错误： 不能给*cptr赋值</span></span><br></pre></td></tr></table></figure><p>​        和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而<strong>没有规定那个对象的值不能通过其他途径改变</strong>。</p><h4 id="2-3-5-1-const指针"><a href="#2-3-5-1-const指针" class="headerlink" title="2.3.5.1 const指针"></a>2.3.5.1 const指针</h4><p>​        指针是对象，因此可以把指针本身定位常量，<strong>常量指针<code>(const pointer)</code></strong>必须初始化，初始化成功后，它的值（存放在指针中的地址）就不能再改变了。<font color=red>不能改变指向</font>，即该变量<code>p</code>不可修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> curErr = &amp;errNumb;  <span class="comment">//curErr将会一直指向errNumb</span></span><br></pre></td></tr></table></figure><h3 id="2-3-6-顶层-const"><a href="#2-3-6-顶层-const" class="headerlink" title="2.3.6 顶层 const"></a>2.3.6 顶层 const</h3><p><code>顶层const</code>表示指针本身就是个常量，可以表示任意对象时常量，对任何数据类型都适用</p><p><code>底层const</code>表示指针指向的对象是个常量，底层const则与指针和引用等否和类型的基本类型部分有关。</p><p>​        当底层const进行拷贝操作时，考入和拷出的对象都必须具有相同的底层const资格，或者俩个对象的数据类型必须能够转换。一般来说，非常量可以转换为常量，反之则不行。                                    </p><h3 id="2-3-7-constexpr-和常量表达式"><a href="#2-3-7-constexpr-和常量表达式" class="headerlink" title="2.3.7 constexpr 和常量表达式"></a>2.3.7 constexpr 和常量表达式</h3><p>​        <strong>常量表达式(const expression)</strong>是指<strong>不会改变</strong>并且在<strong>编译过程就能得到计算结果</strong>的表达式。显然字面值属于常量表达式，用<code>常量表达式初始化的const对象</code>也是常量表达式。</p><p>​        一个对象是不是常量表达式由他的数据类型和初始值共同决定，例如：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> max_files = <span class="number">20</span>; <span class="comment">// max_files 是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = max_files + <span class="number">1</span>; <span class="comment">//limit是常量表达式</span></span><br><span class="line"><span class="type">int</span> staff_size = <span class="number">27</span>;    <span class="comment">//staff_size 不是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>();  <span class="comment">//sz 不是常量表达式</span></span><br></pre></td></tr></table></figure><p>​    尽管staff_size的初始值是个常量，但由于staff_size的值可以改动，所以他并不是一个常量表达式。</p><p>​    同样的，sz本身虽然是一个常量，但是他的值必须在运行时才能知晓，不可以在编译时就定下来，所以他也不是常量表达式。</p><h4 id="2-3-7-1constexpr-变量（constexpr-类型）"><a href="#2-3-7-1constexpr-变量（constexpr-类型）" class="headerlink" title="2.3.7.1constexpr 变量（constexpr 类型）"></a>2.3.7.1<code>constexpr</code> 变量（<code>constexpr</code> 类型）</h4><p>​    在一个复杂系统中，分辨一个初始值到底是不是常量表达式是很难的。</p><p>​    C++11 新标准规定，允许将变量声明为 <code>constexpr</code> 类型，以便编译器来验证变量的值是否是一个常量表达式，声明constexpr的变量一定是一个常量，并且必须要用常量表达式来初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mf = <span class="number">20</span>;<span class="comment">//20 是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> limit = mf + <span class="number">1</span>; <span class="comment">// mf + 1是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> sz = <span class="built_in">size</span>();  <span class="comment">// 只有当size是一个constexpr函数时</span></span><br><span class="line">  <span class="comment">// 才是一个正确的声明语句</span></span><br></pre></td></tr></table></figure><p>​    注意，不可以用普通函数作为<code>constexpr</code>变量的初始值。新标准允许定义一种特殊的<code>constexpr</code>函数，我们可以用<code>constexpr</code>函数去初始化<code>constexpr</code>变量。</p><h4 id="2-3-7-2-字面值类型："><a href="#2-3-7-2-字面值类型：" class="headerlink" title="2.3.7.2 字面值类型："></a>2.3.7.2 字面值类型：</h4><p>​    声明<code>constexpr</code>变量时用到的类型必须有所限制，一般<strong>比较简单，值也显而易见，容易得到</strong>，就把它们称为 <strong>”字面值类型“</strong></p><p>​    目前遇到的数据类型中：算数类型，引用，指针都属于字面值类型。 类不属于字面值类型，也不能被定义为<code>constexpr</code>。</p><p>​    一个<code>constexpr</code>指针的初始值必须是<code>nullptr</code>或者<code>0</code>，或是存储于<font color=red>某个固定地址</font>的对象。</p><h4 id="2-3-7-3-指针与constexpr"><a href="#2-3-7-3-指针与constexpr" class="headerlink" title="2.3.7.3 指针与constexpr"></a>2.3.7.3 指针与constexpr</h4><p>​    如果<code>constexpr</code>声明中定义了一个指针，限定符<code>constexpr</code>仅对指针有效，与指针所指向的对象无关（无法切换指向）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* p = <span class="literal">nullptr</span>; <span class="comment">//指向常量的指针，底层const</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span>*q = <span class="literal">nullptr</span>;  <span class="comment">//指向整数的常量指针，顶层const</span></span><br></pre></td></tr></table></figure><p>​    与其他常量指针类似，<code>constexpr</code>既可以指向常量，也可以指向变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *np = <span class="literal">nullptr</span>; <span class="comment">//指向整数的常量指针，顶层const</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i = <span class="number">42</span>;  <span class="comment">// i的类型是整数常量</span></span><br><span class="line"><span class="comment">// i和j必须定义在函数体之外，全局变量（包括main函数）</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span>* p = &amp;i; <span class="comment">//p是常量指针，指向常量i</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span>* p1 = &amp;j; <span class="comment">//p是常量指针，指向常量i</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-4-处理类型"><a href="#2-4-处理类型" class="headerlink" title="2.4 处理类型"></a>2.4 处理类型</h2><h3 id="2-4-1-类型别名："><a href="#2-4-1-类型别名：" class="headerlink" title="2.4.1 类型别名："></a>2.4.1 类型别名：</h3><p>​    <strong>类型别名（type alias）</strong> 是一个名字，他是某种类型的同义词。</p><p>方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages;<span class="comment">//wages是double的同义词</span></span><br><span class="line"><span class="keyword">using</span> wages = <span class="type">double</span>;   <span class="comment">//wages是double的同义词</span></span><br><span class="line">wages hourly,weekly;    <span class="comment">//等价于 double hourly,weekly;</span></span><br></pre></td></tr></table></figure><p>其中，<code>typedef</code> 作为声明语句中的基本数据类型的一部分出现，含有typedef的声明语句定义的不再是变量，而是<strong>类型别名</strong>。</p><p>​    类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名</p><p>值得注意的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* pint;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> pint b = &amp;a; <span class="comment">//实际上是 int * const b = &amp;a  指向int的常量指针</span></span><br><span class="line">   <span class="comment">//并不是直接的替换 const int* b  :指向int常量的指针</span></span><br></pre></td></tr></table></figure><p>b的基本数据类型是  <code>const pint</code> ，const 是对给定类型的修饰。pstring实际上是指向int 的指针，因此 const pint就是指向int常量的指针。</p><h3 id="2-4-2-auto类型说明符"><a href="#2-4-2-auto类型说明符" class="headerlink" title="2.4.2 auto类型说明符"></a>2.4.2 auto类型说明符</h3><p>​        auto可以在一条语句中声明多个变量，但因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型必须一样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i;<span class="comment">//  正确；i是整数，p是整形指针 他们的基本数据类型都是int，*是修饰符</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>;  <span class="comment">// 错误：sz 和 pi的类型不一致int，double</span></span><br></pre></td></tr></table></figure><h4 id="2-4-2-1-复合类型、常量和auto"><a href="#2-4-2-1-复合类型、常量和auto" class="headerlink" title="2.4.2.1 复合类型、常量和auto"></a>2.4.2.1 复合类型、常量和auto</h4><p><strong>使用引用其实是使用引用的对象</strong>，特别是当引用被用作初始值时，真正参与初始化的其实是<strong>引用对象的值</strong>。此时编译器以引用对象的类型作为auto的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>,&amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r;<span class="comment">// a是一个整数 (r是i的别名，而i是一个整数)</span></span><br></pre></td></tr></table></figure><p>auto一般会忽略掉顶层const，同时底层const则会保留（注重于对象，而不是指针本身）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci; <span class="comment">// b的类型为int，顶层const的特性被忽略掉了</span></span><br><span class="line"><span class="keyword">auto</span> c = cr; <span class="comment">// c是一个整数，（cr是ci的别名，ci本身是一个顶层const，顶层const的特性被忽略掉了）</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i; <span class="comment">// i本身是一个变量，d是一个整型的指针（整数的地址就是指向整数的指针）</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci; <span class="comment">// ci本身是一个顶层const，&amp;i是一个底层const</span></span><br><span class="line"><span class="comment">//（对常量对象取地址是一种底层const）</span></span><br><span class="line"><span class="comment">//底层const 会保留，所以d的类型是const int* (指向整数常量的指针)</span></span><br></pre></td></tr></table></figure><p>如果希望推断出的auto类型是一个顶层const，需要明确指出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f =ci;<span class="comment">//ci的推演类型为int，f是 const int</span></span><br></pre></td></tr></table></figure><p>还可以将引用的类型设为auto：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp; g = ci;  <span class="comment">//g 是一个整形常量的引用</span></span><br><span class="line"><span class="keyword">auto</span> &amp; h = <span class="number">42</span>;        <span class="comment">// 错误，不能为常量绑定引用</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp; j = <span class="number">42</span>;  <span class="comment">// 正确，可以为常量引用绑定字面值</span></span><br></pre></td></tr></table></figure><h3 id="2-4-3-decltype类型指示符"><a href="#2-4-3-decltype类型指示符" class="headerlink" title="2.4.3 decltype类型指示符"></a>2.4.3 <code>decltype</code>类型指示符</h3>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HELLO WORLD!</title>
      <link href="/2024/08/22/2024-09-22%20%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/08/22/2024-09-22%20%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world!"></a>Hello world!</h2><div class="note default simple"><p>Hello world~</p></div><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2024-10-05 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">1.0 -&gt; 1.1.0</a></p></div></div><div class='timeline-item-content'><ol><li>你这个情况我还真没见过。</li><li>这样吧，</li><li>你先在steam搜索<code>千恋*万花</code></li><li>点击购买安装好后立即运行打开<code>千恋*万花</code>,在主页面点击开始游戏进入游戏页面</li><li>然后依次选择<code>说实话</code>、<code>不好说</code>、<code>我觉得很可爱</code>、<code>单独行动</code>、<code>摸摸头</code>、<code>感觉有点担心……</code>和<code>还是别说多余的话比较好</code></li><li>进入丛雨路线</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2024-10-05 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">1.1.0 -&gt; 1.1.1</a></p></div></div><div class='timeline-item-content'><ol><li>你说的都对，</li><li>但是你应该打开bilibili搜索 <code>nachoneko</code> 或者中文名 <code>甘城猫猫</code>。</li><li>这就是 <code>甘城猫猫</code> ，已经很晚了，<code>甘城猫猫</code>很担心你，<code>甘城猫猫</code> 希望你早点休息，不要熬夜，晚安。</li></ol><div align=center class="aspect-ratio">    <iframe src="https://player.bilibili.com/player.html?aid=574866285&&page=1&as_wide=1&high_quality=1&danmaku=0"     scrolling="no"     border="0"     frameborder="no"     framespacing="0"     high_quality=1    danmaku=1     allowfullscreen="true">     </iframe></div><div id="aplayer-oSEOhviA" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="4895239160" data-server="netease" data-type="playlist" data-mode="random" data-autoplay="false" data-listmaxheight="340px" data-preload="auto" data-theme="#e3f2f5" data-volume="0.4" mutex="true"></div></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<!-- GitCalendar容器 --><div id="gitZone"></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/archives/index.html"/>
      <url>/archives/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[:root {  --trans-light: rgba(255, 255, 255, 0.70);  --trans-dark: rgba(25, 25, 25, 0.38);  --border-style: 1px solid rgb(169, 169, 169);  /* --backdrop-filter: blur(5px) saturate(150%); */  /* 亚克力效果 */  --backdrop-filter: none}/* 首页文章卡片 */#recent-posts > .recent-post-item {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 25px;  border: var(--border-style);}/* 首页侧栏卡片 */#aside-content .card-widget {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 18px;  border: var(--border-style);}/* 文章页、归档页、普通页面 */div#post,div#page,div#archive {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border: var(--border-style);  border-radius: 20px;}/* 导航栏 */#page-header.nav-fixed #nav {  background: rgba(255, 255, 255, 0.75);  backdrop-filter: var(--backdrop-filter);}[data-theme="dark"] #page-header.nav-fixed #nav {  background: rgba(0, 0, 0, 0.7) !important;}/* 夜间模式遮罩 */[data-theme="dark"] #recent-posts > .recent-post-item,[data-theme="dark"] #aside-content .card-widget,[data-theme="dark"] div#post,[data-theme="dark"] div#archive,[data-theme="dark"] div#page {  background: var(--trans-dark);}/* 夜间模式页脚页头遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 阅读模式 */.read-mode #aside-content .card-widget {  background: rgba(158, 204, 171, 0.5) !important;}.read-mode div#post {  background: rgba(158, 204, 171, 0.5) !important;}/* 夜间模式下的阅读模式 */[data-theme="dark"] .read-mode #aside-content .card-widget {  background: rgba(25, 25, 25, 0.9) !important;   color: #ffffff;}[data-theme="dark"] .read-mode div#post {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }  /* 翻页按钮居中 */  #pagination {    width: 100%;    margin: auto;  }  /* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}  /* 子菜单横向展示 */  #nav .menus_items .menus_item:hover .menus_item_child {    display: flex !important;  }  /* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */  .menus_items .menus_item:nth-child(5) .menus_item_child {    left: -33px;  }  /* 日间模式不生效 */[data-theme="light"] #site-name,[data-theme="light"] #site-title,[data-theme="light"] #site-subtitle,[data-theme="light"] #post-info {  animation: none;}/* 夜间模式生效 */[data-theme="dark"] #site-name,[data-theme="dark"] #site-title {  animation: light_15px 10s linear infinite;}[data-theme="dark"] #site-subtitle {  animation: light_10px 10s linear infinite;}[data-theme="dark"] #post-info {  animation: light_5px 10s linear infinite;}/* 关键帧描述 */@keyframes light_15px {  0% {    text-shadow: #5636ed 0 0 15px;  }  12.5% {    text-shadow: #11ee5e 0 0 15px;  }  25% {    text-shadow: #f14747 0 0 15px;  }  37.5% {    text-shadow: #f1a247 0 0 15px;  }  50% {    text-shadow: #f1ee47 0 0 15px;  }  50% {    text-shadow: #b347f1 0 0 15px;  }  62.5% {    text-shadow: #002afa 0 0 15px;  }  75% {    text-shadow: #ed709b 0 0 15px;  }  87.5% {    text-shadow: #39c5bb 0 0 15px;  }  100% {    text-shadow: #5636ed 0 0 15px;  }}@keyframes light_10px {  0% {    text-shadow: #5636ed 0 0 10px;  }  12.5% {    text-shadow: #11ee5e 0 0 10px;  }  25% {    text-shadow: #f14747 0 0 10px;  }  37.5% {    text-shadow: #f1a247 0 0 10px;  }  50% {    text-shadow: #f1ee47 0 0 10px;  }  50% {    text-shadow: #b347f1 0 0 10px;  }  62.5% {    text-shadow: #002afa 0 0 10px;  }  75% {    text-shadow: #ed709b 0 0 10px;  }  87.5% {    text-shadow: #39c5bb 0 0 10px;  }  100% {    text-shadow: #5636ed 0 0 10px;  }}@keyframes light_5px {  0% {    text-shadow: #5636ed 0 0 5px;  }  12.5% {    text-shadow: #11ee5e 0 0 5px;  }  25% {    text-shadow: #f14747 0 0 5px;  }  37.5% {    text-shadow: #f1a247 0 0 15px;  }  50% {    text-shadow: #f1ee47 0 0 5px;  }  50% {    text-shadow: #b347f1 0 0 5px;  }  62.5% {    text-shadow: #002afa 0 0 5px;  }  75% {    text-shadow: #ed709b 0 0 5px;  }  87.5% {    text-shadow: #39c5bb 0 0 5px;  }  100% {    text-shadow: #5636ed 0 0 5px;  }}/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {  background: linear-gradient(    -45deg,    #e8d8b9,    #eccec5,    #a3e9eb,    #bdbdf0,    #eec1ea  );  box-shadow: 0 0 5px rgb(66, 68, 68);  position: relative;  background-size: 400% 400%;  -webkit-animation: Gradient 10s ease infinite;  -moz-animation: Gradient 10s ease infinite;  animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@-moz-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {  background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {  background-color: #3eb8be;  border-radius: 8px;}/*哔哩哔哩视频适配*/.aspect-ratio {  position: relative;  width: 90%;  height: auto;  padding-bottom: 75%;  margin: 3% auto;  text-align: center;}.aspect-ratio iframe {  position: absolute;  width: 100%;  height: 86%;  left: 0;  top: 0;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/emoji.css"/>
      <url>/css/emoji.css</url>
      
        <content type="html"><![CDATA[#owo-big {    position: fixed;    align-items: center;    background-color: rgb(255, 255, 255);    border: 1px #aaa solid;    border-radius: 10px;    z-index: 9999;    display: none;    transform: translate(0, -105%);    overflow: hidden;    animation: owoIn 0.3s cubic-bezier(0.42, 0, 0.3, 1.11);}[data-theme=dark] #owo-big {    background-color: #4a4a4a}#owo-big img {    width: 100%;}/* 动画效果代码由 Heo：https://blog.zhheo.com/ 提供 */@keyframes owoIn {    0% {        transform: translate(0, -95%);        opacity: 0;    }    100% {        transform: translate(0, -105%);        opacity: 1;    }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/readPercent.css"/>
      <url>/css/readPercent.css</url>
      
        <content type="html"><![CDATA[/* 返回顶部 */button#go-up #percent {    display: none;    font-weight: bold;    font-size: 15px !important;}button#go-up span {    font-size: 12px!important;    margin-right: -1px;}/* 鼠标滑动到按钮上时显示返回顶部图标 */button#go-up:hover i {    display: block !important;}button#go-up:hover #percent {    display: none !important;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/runtime.css"/>
      <url>/css/runtime.css</url>
      
        <content type="html"><![CDATA[#workboard{font-size:13px;font-weight:700}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[/* 背景宇宙星光  */#universe{    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */    z-index: -1;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/copyremind.js"/>
      <url>/js/copyremind.js</url>
      
        <content type="html"><![CDATA[// 复制提醒document.addEventListener("copy", function () {    debounce(function () {        new Vue({            data: function () {                this.$notify({                    title: "哎嘿！复制成功🍬",                    message: "若要转载最好保留原文链接哦，给你一个大大的赞！",                    position: 'top-left',                    offset: 50,                    showClose: true,                    type: "success",                    duration: 5000                });            }        })    }, 300);})]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/emoji.js"/>
      <url>/js/emoji.js</url>
      
        <content type="html"><![CDATA[// 如果当前页有评论就执行函数if (document.getElementById('post-comment')) owoBig();// 表情放大function owoBig() {    let flag = 1, // 设置节流阀        owo_time = '', // 设置计时器        m = 3; // 设置放大倍数    // 创建盒子    let div = document.createElement('div'),        body = document.querySelector('body');    // 设置ID    div.id = 'owo-big';    // 插入盒子    body.appendChild(div)    // 构造observer    let observer = new MutationObserver(mutations => {        for (let i = 0; i < mutations.length; i++) {            let dom = mutations[i].addedNodes,                owo_body = '';            if (dom.length == 2 && dom[1].className == 'OwO-body') owo_body = dom[1];            // 如果需要在评论内容中启用此功能请解除下面的注释            // else if (dom.length == 1 && dom[0].className == 'tk-comment') owo_body = dom[0];            else continue;                        // 禁用右键（手机端长按会出现右键菜单，为了体验给禁用掉）            if (document.body.clientWidth <= 768) owo_body.addEventListener('contextmenu', e => e.preventDefault());            // 鼠标移入            owo_body.onmouseover = (e) => {                    if (flag && e.target.tagName == 'IMG') {                        flag = 0;                        // 移入300毫秒后显示盒子                        owo_time = setTimeout(() => {                            let height = e.path[0].clientHeight * m, // 盒子高                                width = e.path[0].clientWidth * m, // 盒子宽                                left = (e.x - e.offsetX) - (width - e.path[0].clientWidth) / 2, // 盒子与屏幕左边距离                                top = e.y - e.offsetY; // 盒子与屏幕顶部距离                            if ((left + width) > body.clientWidth) left -= ((left + width) - body.clientWidth + 10); // 右边缘检测，防止超出屏幕                            if (left < 0) left = 10; // 左边缘检测，防止超出屏幕                            // 设置盒子样式                            div.style.cssText = `display:flex; height:${height}px; width:${width}px; left:${left}px; top:${top}px;`;                            // 在盒子中插入图片                            div.innerHTML = `<img src="${e.target.src}">`                        }, 300);                    }                };            // 鼠标移出隐藏盒子            owo_body.onmouseout = () => { div.style.display = 'none', flag = 1, clearTimeout(owo_time); }        }    })    observer.observe(document.getElementById('post-comment'), { subtree: true, childList: true }) // 监听的 元素 和 配置项}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/f12.js"/>
      <url>/js/f12.js</url>
      
        <content type="html"><![CDATA[document.onkeydown = function (e) {    if (123 == e.keyCode || (e.ctrlKey && e.shiftKey && (74 === e.keyCode || 73 === e.keyCode || 67 === e.keyCode)) || (e.ctrlKey && 85 === e.keyCode)) return btf.snackbarShow("控制台被我ban了喔~~!"), event.keyCode = 0, event.returnValue = !1, !1};]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/readPercent.js"/>
      <url>/js/readPercent.js</url>
      
        <content type="html"><![CDATA[window.onscroll = percent;// 执行函数// 页面百分比function percent() {    let a = document.documentElement.scrollTop || window.pageYOffset, // 卷去高度        b = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight) - document.documentElement.clientHeight, // 整个网页高度        result = Math.round(a / b * 100), // 计算百分比        up = document.querySelector("#go-up") // 获取按钮    if (result <= 95) {        up.childNodes[0].style.display = 'none'        up.childNodes[1].style.display = 'block'        up.childNodes[1].innerHTML = result;    } else {        up.childNodes[1].style.display = 'none'        up.childNodes[0].style.display = 'block'    }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.js"/>
      <url>/js/runtime.js</url>
      
        <content type="html"><![CDATA[setInterval(() => {    let create_time = Math.round(new Date('2024-09-23 00:00:00').getTime() / 1000); //在此行修改建站时间    let timestamp = Math.round((new Date().getTime()) / 1000);    let second = timestamp - create_time;    let time = new Array(0, 0, 0, 0, 0);      var nol = function(h){      return h>9?h:'0'+h;    }    if (second >= 365 * 24 * 3600) {      time[0] = parseInt(second / (365 * 24 * 3600));      second %= 365 * 24 * 3600;    }    if (second >= 24 * 3600) {      time[1] = parseInt(second / (24 * 3600));      second %= 24 * 3600;    }    if (second >= 3600) {      time[2] = nol(parseInt(second / 3600));      second %= 3600;    }    if (second >= 60) {      time[3] = nol(parseInt(second / 60));      second %= 60;    }    if (second > 0) {      time[4] = nol(second);    }    if ((Number(time[2])<22) && (Number(time[2])>7)){      currentTimeHtml ="<img class='boardsign' src='https://img.shields.io/badge/糖果屋-营业中-6adea8?style=social&logo=cakephp' title='距离百年老店也就差不到一百年~'><div id='runtime'>" + time[0] + ' YEAR ' + time[1] + ' DAYS ' + time[2] + ' : ' + time[3] + ' : ' + time[4] + '</div>';    }    else{      currentTimeHtml ="<img class='boardsign' src='https://img.shields.io/badge/糖果屋-打烊了-6adea8?style=social&logo=coffeescript' title='再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的每一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨'><div id='runtime'>" + time[0] + ' YEAR ' + time[1] + ' DAYS ' + time[2] + ' : ' + time[3] + ' : ' + time[4] + '</div>';    }    document.getElementById("workboard").innerHTML = currentTimeHtml;  }, 1000);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
